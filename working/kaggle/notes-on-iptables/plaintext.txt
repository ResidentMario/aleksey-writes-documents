IPTables is the Linux system administration tool for setting packet-level (e.g. IP protocol, e.g. level 3) flow control rules on a machine. Rules can be added using IPtables to change where packets are routed to or to drop them entirely. We use this tooling in our AMI definition at Spell to e.g. prevent the sandboxed user from accessing the AWS metadata service, and Kubernetes uses this service for its packet routing needs. So it makes sense for me to take a minute to study it more formally. In order to understand how iptables works one must first understand how networking on Linux is set up. UNIX has a concept of a network interface. Network interfaces are registered hardware or software devices which are supposed to accept packets and deal with them. You can list network interfaces by running ifconfig, for example on my machine I see: Network interfaces are assigned responsibility for certain ranges of IP addresses by the routing table. You can view the routing table using netstat -r -n: In iptables there are rules collected into sets called chains which are then assigned to tables. There are apparently three default tables. The one of these which is most commonly used is the filter table, which contains three chains: INPUT for incoming packets, FORWARD for packets being forwarded internally, and OUTPUT for outgoing packets. A packet rule may have one of four dispositions: ACCEPT, DROP, RETURN, or a different chain target. A combination of RETURN rules and chain targets may be used to enact control flow over a packet: e.g. to bounce it around amongst many different chains. This is probably why they're called "chains" and not just something simpler, like "sets". The default iptables rules have nothing set, e.g. they allow all traffic. This is good on a local machine, bad if you're in systems service, bad. Rules are matched in a descending manner. The first rule that matches the packet is the one that gets used. The combination of RETURN and chain forwarding allows for overlapping rules to be specified, but this an advanced and rarely used feature in practice. You use iptables -I to insert a rule into a table (or -A to append one). Rules have a rule number, and specifying the optional rule number as the second argument to this command will insert that rule at that number, overwriting the existing one. Unparameterized -I will insert at the head of the table (e.g. prepend the value). The full rule creation syntax is: Going through these one by one: With that in mind here are some simple rules we set in our AMI: Here DOCKER-USER is a new chain in the default table created by our Docker network setup commands and $bridge_name is an interface created by the Docker network setup commands (more on that stuff later). The IP addresses are interesting. 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 are the three private IP addresses: all private intranetwork services listen on these addresses, and e.g. router NAT-ing is performed by assigning machines private IP addresses from these ranges. I don't think that any of the IP addresses besides 169.254.169.254 are sensitive, but we do drop the full two bytes (or octets, as IP address components are often referred to) of addresses anyway, just cause. Apparently some of our VPC connection points are in the public address space, which is interesting. That's the reason why the last set of IP address drop rules has been added. Not clear what happens if I want to access a service that happens to fall inside of this IP address range. Docker networking is controlled using drivers. The default driver is the bridge network; this is the network that is recommended for standalone Docker containers. Others exist, and are complicated. We use a non-default bridge network driver: I am fairly sure that since we perform no further configuration on this network we only do this so that we may control the bridge network name by hand: it's set to bridge_name="docker-sandbox" immediately before this command is run. Docker provides a specific reference page on manipulating iptables network rules in a Docker-friendly way, as, it turns out, Docker also manipulates iptables rules. Here's the page: https://docs.docker.com/network/iptables/. Basically, Docker creates a bunch of network isolation rules that are in the DOCKER table, and creates a DOCKER-USER table that you can add your own rules to, should you desire to do so. These rules will be read ahead of the Docker-controlled network isolation rules. So we also have this bit here: This uses a couple of more advanced iptables features: Yeah so the last thing we run that's iptables related is persisting it: iptables rules are in-memory by default; they do not survive machine restart. To persist the rules you need to use iptables-save. iptables-save saves the current IP tables rules to a file. We are doing so by writing to /etc/iptables/rules.v4 here. This is the expected name for all saved IPv4 rules; the expected name for saved IPv6 rules is /etc/iptables/rules.v6, logically enough. iptables-persistent is the UNIX built-in that manages rules persistence. debconf-set-selections is...apparently it's a UNIX utility for setting a bank of questions and answers that are used for system package behavior configuration. It's debconf because it's a Debian thing, and Ubuntu is based on Debian (something that I was not aware of because it comes up approximately never). I will write a seperate notebook on Unbuntu package management to capture this knowledge in a reference. The --auto-remove option on apt-get configures automatic uninstallation of dependent packages when the iptables-persistent package is removed. 