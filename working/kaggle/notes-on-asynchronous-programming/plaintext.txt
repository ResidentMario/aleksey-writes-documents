The trade-off, of course, is complexity. It is called "cooperative" because all tasks/commands must cooperate for the entire scheduling scheme to work. They are interleaved with one another, but in a single thread of control, known as a cooperative scheduler, having its role reduced down to starting the processes and letting them return control back to it voluntarily. From section 4: This is how async code can have so many things happening at once - anything that's blocking calls await, and gets put onto the event loop's list of paused coroutines so something else can run. Everything that's paused has an associated callback that will wake it up again â€” some are time-based, some are I/O-based, and most of them are like the example above and waiting for a result from another coroutine. Final recommendation: 