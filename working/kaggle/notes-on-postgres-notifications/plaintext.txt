Postgres provides a simple IPC mechanism through its database via its notifications feature. These brief notes taken from this page in the Postgres docs. To use notifications you must set up senders and listeners that communicate over channels. The API for doing so uses NOTIFY and LISTEN SQL commands unique to Postgres, and is very simple (the following example given in the documentation as an example psql session): Notice that notifications have a string payload. This field is optional and a notification may be sent with no payload whatsoever. Here's what the docs say on when notifications events arrive. TLDR they only arrive and send in between transactions, so processes relying on notifications should have their transactions be short-lived. NOTIFY interacts with SQL transactions in some important ways. Firstly, if a NOTIFY is executed inside a transaction, the notify events are not delivered until and unless the transaction is committed. This is appropriate, since if the transaction is aborted, all the commands within it have had no effect, including NOTIFY. But it can be disconcerting if one is expecting the notification events to be delivered immediately. Secondly, if a listening session receives a notification signal while it is within a transaction, the notification event will not be delivered to its connected client until just after the transaction is completed (either committed or aborted). Again, the reasoning is that if a notification were delivered within a transaction that was later aborted, one would want the notification to be undone somehow â€” but the server cannot "take back" a notification once it has sent it to the client. So notification events are only delivered between transactions. The upshot of this is that applications using NOTIFY for real-time signaling should try to keep their transactions short. Backpressure is managed via a (very large) queue: There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling NOTIFY will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes LISTEN and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed. We use notifications of the form NOTIFY event_type optional_message at Spell. E.g. event types are channels and messages are optional. The current list of event types is: These events are used by the goroutine schedulers handling the various run types to know when to perform certain actions without having to perform IPC between parallel goroutines. This allows for good separation of concern. 