On the other hand, having all of your built-in types live as reference types has an attractive property: it makes for a unified type interface. Value types can only be used for fixed-width types and objects, flexibly-sized objects like arrays and the like must be reference types. Programming languages that allow for flexibly-sized objects (and all high-level languages do) must implement them as reference types. If that language chooses to have some or all builtins live as value types, then the low-level interface to different types is vastly different. This puts the burden of representation on the user. Python and JavaScript opt to use more memory and accept a bit of slowdown in order to have unification. Languages that feature both value types and reference types implement boxing and unboxing instead. Boxing a value type turns it into a reference type (by wrapping it in an object). Unboxing a reference type turns it back into a value type. In C# for example: Turning a value type into a reference type in this manner allows C# programs to include features like container types containing value types with minimal fuss (the values are simply boxed as they are placed in the container). However, because this operation is not free, it causes runtime slowdown. 