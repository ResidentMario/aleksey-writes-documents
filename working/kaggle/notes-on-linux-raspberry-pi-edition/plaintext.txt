The Filesystem Hierarchy Standard is a trailing standard, not a leading standard. Although Linux distros conform to the major points of the standard, and indeed have to to maintain compatibility, there are some small differences in behaviors between distributions. And more prominently, there are new additions or new experimental features that are present in many distros that have not yet made it into the standard. Here, we list the interesting and non-obvious ones. /bin — contains binary executables (e.g. command-line executables like ls et. al.) that are runable in single-user mode. Single-user mode is a special boot mode which boots the machine into a single superuser. This mode disables network resources, so it can be used for security purposes (like, say, depriving a known computer virus from access to the Internet in the process of trying to quarantine and erase it). It is also often used to perform administrative tasks that require sole ownership over a shared resource. The Wikipedia article on this subject lists running fsck (a filesystem consistency tool) on a networked resource (e.g. an NFS server). Single-user model is initialized via boot options, and is Linux's equivalent to Windows safe mode, as it initializes only a very safe subset of processes (leaving out, for instance, the X Window Server; you only get terminal in full-screen mode). Needless to say, only the superuser can write into this folder, and you really shouldn't ever need to do it unless you're doing something at the sysadmin level. /dev — short for device; this is a primary location for devices mounted onto the filesystem as regular read/write I/O pipes. Device mounts are a useful abstraction because they allow you to use the standard Linux commands for reading to and writing from a file with devices (or partitions of devices, or even software-defined devices that don't actually correspond to any hardware) besides the boot device. This fits with Linux's general "everything is a file" philosophy. Some examples of devices include: The developer tools in-memory (on-RAM via tmpfs) device, mounted to /dev, which includes gems like /dev/null and /dev/random and /dev/urandom (/dev/urandom is "unlimited random", which is non-blocking, unlike /dev/random; it's theoretically less safe than /dev/random but not mainstream attack against it has been discovered as of yet). TODO: explore the tools available in /dev further. /etc — short for etcetera; used for files meant to be available system wide. For example, a fresh install of RASPIAN has an etc/matplotlibrc file, and Apache installs its config files in /etc/apache2. /run — A RAM-mounted (tmpfs) space meant as a scratch space for files written by daemons, especially during the startup process. Used to store things like lockfiles and the like. systemd for example writes a pile of stuff into here. /sbin — For super-user only binary executables that can be run in single-user mode. One thing that the Linux file hierarchy doesn't make clear is the boundary between "stuff installed in /usr/local and /home/$username/.local (alias ~/.local). This is because the spec sucked on this point, and the standard that eventually emerged is as follows: /usr/local is a place where software usable by all users can be installed by an administrator. ~/.local/bin is a place where a user can install software for their own use. There is some messiness in the history of the directory structure used in different distros and communities, but this covers the basic differences. The /home/$username.local folder has its own bin, lib, and share directories, just as / (root), usr/ (all user), and usr/local (current user) all do. It is meant to be the place where you, the user, install stuff. For example, on my Pi, python3 -m pip install virtualenv installed the virtualenv binary in ~/.local/bin. There are two types of sockets on a modern Linux machine. The first and vastly less common type is the Unix domain socket. This is a socket type that is constrained to the local machine, and is designed to play well with how Unix works (e.g. it is file-based, takes advantage of userland permissions, etcetera). The second and predominant socket type is the Berkeley socket. Berkeley sockets are the socket API used across all of Linux, macOS, and Windows for connecting a machine to a network. These are two distinct subsystems. Because Berkeley sockets are much more useful and also instantly portable, they're generally what people mean when they talk about "sockets". Network programming on a local machine level means dealing with sockets. Sockets are a transport layer standard, so they are made to work with a variety of transport layer protocols, which in practice means either TCP or UDP. When specifying what a socket should listen to, you need to set the transport protocol you are using and the port number you are using. Port numbers below 1024 are reserved and require superuser privileges to listen to. Two well-known port numbers are 80 for HTTP traffic and 443 for TLS/HTTPS traffic. The next layer over the transport layer is the Internet layer, which almost always means IP. Although you can omit identification and send and recieve anonymous packets with a raw port, in practice TCP and UPD almost always mean TCP/IP or UDP/IP. So in the Python sockets API for example you can set your expected traffic type to IPv4 or IPv6, and the library will handle de-encapsulating the data payload and reading out the IP address identifier for you. Working with a socket generally proceeds thusly. First you create a listener socket and bind it to a certain IP address and port number on that machine. Connection requests (SYN packets) bound for that address are forwarded to the listener socket, which is able to then attach that connection to a new connected socket, which handles the rest of the handshake and the ensuing two-way communication. After spinning off the new socket, the listener socket goes back to waiting for new connection requests. Files are the simplest way of performing IPC: write some data to a file, and let other processes read from that file to find out the current state of the system. The "everything is a file" Unix philosophy is very conducive to this organizational format. You don't even need to read from disk (slow) to do this, as you can mount a filesystem partition in tmpfs RAM (or use one of the RAM filesystem partitions that Linux provides by default) to make it a read operation from memory instead (fast). 