Only one run orchestrator may safely be running at a time. Since there are failure scenarios which result in multiple orchestrators being live, the first thing that the run orchestrator does when it starts up is acquire a database lock: This code is provided by the spell/db/mutex package. A mutex in this context is a Postgres advisory lock. The page in the Postgres documentation on locking states that Postgres advisory locks are locks that can be registered with Postgres which have application-defined meaning, they do not actually lock anything in the database itself. Some behaviors: The package contains two functions, Lock and Unlock. Lock returns a lockedMutex struct with two fields: an integer ID value Mutex and the pg.Tx go-pg transaction struct used to acquire the lock. Unlock hangs off of the lockedMutex struct and gets called in a defer at orchestrator exit time to release the advisory lock in the case of a graceful exit. In the case of an ungraceful exit, Postgres cleans up the advisory lock at connection failure time. The transaction handling the advisory lock is held open for the duration of the session. Recall that transcations provide a guarantee that actions within them can be rolled back later. Since advisory locks do not touch tables, this long-lived transaction has no adverse effect on the performance of any other transactions, as Postgres does not have to perform any database locking in order to roll it back (which in this context just means dropping the advisory lock). As a sidebar, note that Postgres provides a form of transaction concurrency known as MVCC, short for multi-version concurrency control, at the default read committed level (I don't work with distributed systems nearly enough to retain what this all means in my head, so here's my notes on transactions from DDIA). The Postgres docs cite page 59 of a slide deck as a good reference on what this means. But basically it just means that queries in a transaction see a database state only containing all completed transactions at transaction open time, plus changes made by previous transactions in the query. Plus transaction modify operations are performed near their time of declaration, e.g. they are not held until the transaction is flushed. Advisory locks are held against an ID value: They can be associated with other things, like table data, but this is how we use them at Spell. We initialize the ID with the golang iota. iota is an incrementing value which counts up by one every time a non-whitespace LOC is executed. It is reset back to 0 every time it is redeclared. There's no real reason to use iota for this instead of, say, a constant number, that I know of. 