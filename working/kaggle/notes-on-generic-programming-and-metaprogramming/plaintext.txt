Why are flexibly-typed containers an example of a so-called generic? In a statically typed language like C++ the base array class must be typed. So you can haved a typed int array or a typed character array. There is no equivalent of the flexibly-typed Python list primitive. C++ gets around this with the template feature. A template allows you to intialize a class in which the type is declared lazily, at instantiation time instead of at declaration time. Example code snippet: This is a generic. The class is defined in a manner generic with respect to types. The classes are initialized when you use them: MyContainer<int>, MyContainer<float>, MyContainer<String>, etcetera. Objects are minted created using a special class object factory function. Class objects are themselves an object; the object that creates the class object is the type built-in by default. These two are equivalent: But it's possible to write a different class object instantializer. This lets you inject arbitrary code into object instantiationâ€”this is the power of metaprogramming. For example, see how easy it is to add some base values using metaprogramming: Why? Because adding this feature would increase the complexity and slow down the operation of the language: Why does Go not have generic types? Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do. Generics are convenient but they come at a cost in complexity in the type system and run-time. We haven't yet found a design that gives value proportionate to the complexity, although we continue to think about it. Meanwhile, Go's built-in maps and slices, plus the ability to use the empty interface to construct containers (with explicit unboxing) mean in many cases it is possible to write code that does what generics would enable, if less smoothly. Why is implementing generics a source of complexity? See these notes from one of the Go authors. There's a few ways of implementing generics. The execution can handle genericism at runtime. This is what Java does. This slows down execution, as it requires boxing and unboxing. I did not immediately know what boxing and unboxing is so I had to go learn about that first, here's the notes: Notes on boxing and unboxing. How does boxing and unboxing help? It allows us to write containers that are typed to <Object>. We can then place value types into the array by boxing them into objects, and retrieve them from the array by unboxing them back to their native type. This operation is not free, so it makes things slower at runtime. On the other hand it doesn't result in source code bloat (and compile-time slowdown) like templates do. 