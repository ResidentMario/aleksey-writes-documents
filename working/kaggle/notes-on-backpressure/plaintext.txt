And then we run into the following eclectic statement: In threaded code any function can yield. In async code only async functions can. This means for instance that the writer.write method cannot block. This statement took me a long time to understand. I understand that promises and generators can be combined to produce the same code that async/await can produce, so I thought that there was some deeper connection between the yield keyword statement in Python generators and asynchronous functions, so I spend some time reading an article on this, but ultimately I gave up and asked SO, which told me that the word "yield" in this context merely means "return control of execution to other functions". Whether in a synchronous function or an asynchronous one, a synchronous function will hold the thread hostage until it is complete. If it is located in an asynchronous function, that function will not get to release the execution context until the synchronous function is complete. In other words, synchronous functions are uninterruptable. E.g.: This poses a problem: if a synchronous function blocks for a long time, all of the sudden the asynchronous function is behaving like a synchronous one, e.g. not letting anything else run. A smart way to handle this is to use semaphores: A semaphore is a flag that can be acquired by a function and then released by that function. This is as simple as a reserved byte in memory. In conclusion: async/await is great but it encourages writing stuff that will behave catastrophically when overloaded. On the one hand because it's just so easy to queue but also because making a function async after the fact is an API breakage. I can only assume this is why Python still has a non awaitable write function on the stream writer. 